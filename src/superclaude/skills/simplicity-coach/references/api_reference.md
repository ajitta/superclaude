# Orient-Step-Learn 적용 사례집

> 이 문서는 SKILL.md에서 `references/orient-step-learn-examples.md`로 참조됨.
> Orient-Step-Learn 프레임워크의 구체적 적용 사례를 담고 있다.

---

## 사례 1: 새 API 엔드포인트 개발

### Orient
- **현재**: 사용자 목록을 반환하는 `/users` API만 존재
- **목표**: 사용자 프로필 상세 조회 `/users/{id}/profile` 추가
- **완료 기준**: GET 요청으로 사용자 이름, 이메일, 가입일을 JSON으로 반환

### Step 1
가장 핵심적인 시나리오: id로 사용자 1명을 조회하여 이름만 반환하는 엔드포인트.
```python
@app.get("/users/{user_id}/profile")
def get_profile(user_id: int):
    user = db.get_user(user_id)
    return {"name": user.name}
```

### Learn 1
- 동작 확인됨. 존재하지 않는 user_id에 대해 500 에러 발생 → 404 처리 필요.
- DB 쿼리가 불필요하게 전체 컬럼을 가져옴 → 다음 단계에서 최적화.

### Step 2
404 처리 추가 + 필요한 필드만 반환하도록 수정.

### Learn 2
- 에러 처리 패턴이 다른 엔드포인트와 일관되지 않음 발견 → 공통 에러 핸들러 고려.
- 이 발견은 프로세스 버그: 에러 처리에 대한 팀 컨벤션이 없었음.

---

## 사례 2: 레거시 코드 리팩토링

### Orient
- **현재**: 5000줄짜리 `utils.py`에 온갖 함수가 섞여 있음
- **목표**: 관련 함수들을 모듈별로 분리하여 가독성 향상
- **완료 기준**: 각 모듈이 하나의 관심사만 다루고, 기존 테스트가 모두 통과

### Step 1
가장 큰 함수 그룹(날짜 관련 10개 함수)만 `date_utils.py`로 추출.
import 수정, 테스트 실행.

### Learn 1
- 테스트 통과. 그런데 날짜 함수 중 3개가 `string_utils`의 함수를 호출하고 있었음.
- 순환 의존성 가능성 발견 → 다음 단계에서 의존 방향 확인 필요.

### Step 2
의존성 그래프를 그려봄. string_utils → date_utils 방향은 OK. 역방향 없음 확인.
string_utils 관련 8개 함수를 분리.

### Learn 2
- 분리 후 테스트 1개 실패: mock이 `utils.string_format`을 직접 참조하고 있었음.
- 피드백 3층위 적용:
  - 코드 버그: mock 경로 수정
  - 기대 버그: 해당 없음
  - 프로세스 버그: mock에서 구현 경로를 하드코딩하는 패턴이 리팩토링에 취약함

---

## 사례 3: 기술 선택 — 상태 관리

### Orient
- **현재**: React 앱에서 prop drilling이 5단계 이상으로 깊어짐
- **목표**: 적절한 상태 관리 도입
- **완료 기준**: prop drilling 2단계 이하로 줄임, 번들 크기 증가 최소화

### 의존성 질문 적용
| 선택지 | 사용할 기능 | 직접 구현 가능? | 가역성 |
|--------|-----------|---------------|--------|
| Redux | 전역 store + selector | 과한 보일러플레이트 | 낮음 (전체 구조 변경) |
| Zustand | 전역 store | 3줄 hook으로 대체 가능한 수준 | 중간 |
| React Context | Provider + useContext | 이미 내장 | 높음 (표준 API) |
| Jotai | 원자적 상태 | 직접 구현 어려움 | 중간 |

### Step 1
가역성이 가장 높은 React Context로 먼저 시도.
가장 깊은 prop drilling 체인 1개만 Context로 전환.

### Learn 1
- 5단계 → 1단계로 감소. 코드 명확해짐.
- 그러나 Context를 읽는 컴포넌트가 20개 → 리렌더링 우려.
- 현재 성능 문제는 없음. YAGNI 원칙: 성능 문제가 실제로 발생할 때 대응.

---

## 사례 4: 의존성 감사

### 프로젝트 상황
`package.json`에 47개의 직접 의존성. `node_modules`는 1,200개 패키지.

### Step 1: 사용하지 않는 의존성 식별
```bash
npx depcheck
```
결과: 8개의 사용되지 않는 의존성 발견.

### Learn 1
8개 중 3개는 빌드 도구가 암묵적으로 사용 → 실제 미사용은 5개.
5개 제거 후 빌드/테스트 통과 확인.

### Step 2: 대체 가능한 의존성 식별
`moment.js` (300KB) → 프로젝트에서 사용하는 함수: `format()`, `diff()`, `isValid()` 3개.
3개 함수를 네이티브 `Intl.DateTimeFormat`과 20줄의 유틸리티 함수로 대체.

### Learn 2
- 번들 크기 280KB 감소
- 빌드 시간 2초 단축
- 날짜 포맷 중 하나(`'Do'` — "1st", "2nd" 등)가 네이티브로 불가능 → 10줄 추가로 해결
- 프로세스 버그: 프로젝트 시작 시 "다들 쓰니까"라는 이유로 moment.js를 추가했음

---

## 사례 5: 디버깅 — 3층위 피드백

### 버그
사용자가 폼 제출 시 간헐적으로 데이터가 저장되지 않음.

### 1층위: 코드의 버그
race condition — 두 개의 비동기 요청이 동시에 발생할 때 하나가 무시됨.
수정: debounce 적용.

### 2층위: 기대의 버그
테스트에서 "폼 제출 시 데이터가 저장된다"만 검증.
동시 제출 시나리오를 테스트하지 않았음.
수정: concurrent submission 테스트 추가.

### 3층위: 프로세스의 버그
왜 이런 race condition이 발생했는가?
- 버튼에 disable 처리를 하지 않아 사용자가 여러 번 클릭 가능했음
- UI 피드백(로딩 스피너)이 없어 사용자가 "안 눌렸나?"라고 생각하고 재클릭

근본 원인: 비동기 작업에 대한 UI 피드백 패턴이 프로젝트에 없었음.
수정: 비동기 작업 시 UI 피드백 가이드라인 수립.

이 3층위 분석을 DAYBOOK.md에 기록하면, 향후 비슷한 패턴을 직감적으로 감지할 수 있게 된다.
