# Dependency Audit Checklist

> This document is referenced from SKILL.md as `references/dependency-audit-checklist.md`.

---

## Checklist Before Adding a New Dependency

### Required Questions (3)

| # | Question | Answer |
|---|----------|--------|
| 1 | How many lines of this library's features do we actually use? | |
| 2 | How long would it take to write those lines ourselves? | |
| 3 | Are we confident this dependency will remain safe and compatible in 6 months? | |

### Justification Conditions (at least one must be met)

- [ ] Domain requiring specialized knowledge (cryptography, compression, media processing, etc.)
- [ ] Would require hundreds of lines to implement ourselves + many edge cases
- [ ] Library is mature with active maintenance (release within the last 6 months)
- [ ] Using the library's core functionality (not a peripheral utility)
- [ ] Security vulnerability patches are handled promptly by the project

### Warning Signs (reconsider if any apply)

- [ ] Using less than 10% of the library's functionality
- [ ] No releases in the past year
- [ ] Only 1 maintainer
- [ ] 50+ transitive dependencies
- [ ] "Everyone uses it" is the only reason
- [ ] Functionality is replaceable with native APIs

---

## Regular Audit of Existing Dependencies

### Quarterly Review

1. **Identify unused dependencies**
   - `npx depcheck` (Node.js)
   - `pip-autoremove --list` (Python)
   - `bundle clean --dry-run` (Ruby)

2. **Check for security vulnerabilities**
   - `npm audit` / `yarn audit`
   - `pip-audit`
   - `bundle audit`

3. **Evaluate replaceability**
   - Can it be replaced with native APIs?
   - Is there a lighter alternative?
   - Can we extract only the features we use (tree-shaking)?

### Orient-Step-Learn for Dependency Removal

1. **Orient**: Understand what the dependency does, where it's used, and how to replace it
2. **Step**: Remove only one dependency and run tests
3. **Learn**: Build pass? Runtime errors? Performance changes?

---

## Hidden Costs of Dependencies

Concrete forms of the "time bomb" Dave Thomas describes:

- **Supply Chain Attack**: Sept 2025 npm incident â€” 18 packages including chalk, debug were compromised
- **Breaking Change**: API changes during major version updates
- **Dependency Hell**: A requires B@1.x while C requires B@2.x
- **Abandoned Maintenance**: Maintainer abandons the project
- **License Change**: Transition from open source to commercial (Redis, Elasticsearch cases)
- **Performance Debt**: Unused code increases bundle size and build time

Every dependency carries all of these risks.
"Is it worth taking on these risks just to save 3 lines?" is the key question.
